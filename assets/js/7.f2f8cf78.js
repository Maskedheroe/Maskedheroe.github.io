(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{376:function(a,t,_){"use strict";_.r(t);var v=_(45),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"数据挖掘笔记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据挖掘笔记"}},[a._v("#")]),a._v(" 数据挖掘笔记")]),a._v(" "),_("h2",{attrs:{id:"基本认识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本认识"}},[a._v("#")]),a._v(" 基本认识")]),a._v(" "),_("p",[a._v("数据挖掘是由一系列能够帮助人们从大量数据中获取知识的核心算法构成的。它是一门融合了数据库系统、统计学、机器学习和模式识别等领域的概念的交叉学科。")]),a._v(" "),_("h3",{attrs:{id:"数据挖掘解决了什么问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据挖掘解决了什么问题"}},[a._v("#")]),a._v(" 数据挖掘解决了什么问题")]),a._v(" "),_("h4",{attrs:{id:"目前遇到了什么问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目前遇到了什么问题"}},[a._v("#")]),a._v(" 目前遇到了什么问题")]),a._v(" "),_("p",[a._v("面对爆炸增长的数据，急需一个功能强大和通用的工具，以便从海量数据发现有价值的信息。而数据挖掘便是来解决该问题")]),a._v(" "),_("h4",{attrs:{id:"该如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#该如何解决"}},[a._v("#")]),a._v(" 该如何解决？")]),a._v(" "),_("p",[a._v("观点：数据挖掘是从大量数据中挖掘有趣模式和知识的过程，数据源包括数据库、数据仓库、web、其他信息存储库或动态地流入系统的数据")]),a._v(" "),_("h3",{attrs:{id:"数据挖掘是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据挖掘是什么"}},[a._v("#")]),a._v(" 数据挖掘是什么")]),a._v(" "),_("p",[a._v("简洁明了-即从数据中挖掘知识")]),a._v(" "),_("h2",{attrs:{id:"基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[a._v("#")]),a._v(" 基本概念")]),a._v(" "),_("h3",{attrs:{id:"数据库基本知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库基本知识"}},[a._v("#")]),a._v(" 数据库基本知识")]),a._v(" "),_("p",[a._v("关系数据库是表的汇集，每个表都包含一组"),_("strong",[a._v("属性")]),a._v("（列或者字段），并且存放大量"),_("strong",[a._v("元组")]),a._v("（记录或行）\n关系表中的每个元组代表一个"),_("strong",[a._v("对象")])]),a._v(" "),_("h4",{attrs:{id:"表头"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#表头"}},[a._v("#")]),a._v(" 表头")]),a._v(" "),_("p",[a._v("表头又称关系模式")]),a._v(" "),_("h3",{attrs:{id:"数据的几何和代数描述"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据的几何和代数描述"}},[a._v("#")]),a._v(" 数据的几何和代数描述")]),a._v(" "),_("p",[a._v("需要回忆向量、线性相关无关和秩这些基本概念。")]),a._v(" "),_("h3",{attrs:{id:"数据的基本统计描述-数据的概率观点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据的基本统计描述-数据的概率观点"}},[a._v("#")]),a._v(" 数据的基本统计描述（数据的概率观点）")]),a._v(" "),_("p",[a._v("需要回忆一些常用分布函数")]),a._v(" "),_("h4",{attrs:{id:"度量数据散布"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#度量数据散布"}},[a._v("#")]),a._v(" 度量数据散布")]),a._v(" "),_("p",[a._v("极差(range)\n是最大值和最小值之差\n分位数是数据分布每隔一定间隔的点\n2分位数-对应中位数\n4分位数-有三个数据点\n百分位数-分成100个连贯集")]),a._v(" "),_("p",[a._v("方差和标准差(数据分布的散步程度)\n低标准差意为数据观测的趋向 非常靠近均值。高标准差则表示数据散布在一个大的值域中。")]),a._v(" "),_("h4",{attrs:{id:"图形显示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图形显示"}},[a._v("#")]),a._v(" 图形显示")]),a._v(" "),_("p",[a._v("有助于可视化地审视数据，对数据预处理有帮助")]),a._v(" "),_("h4",{attrs:{id:"minkowski-distance"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#minkowski-distance"}},[a._v("#")]),a._v(" Minkowski Distance")]),a._v(" "),_("p",[a._v("闵式距离是距离的定义。\n距离公式：\n"),_("br"),a._v(" "),_("img",{staticStyle:{width:"200px",height:"100px"},attrs:{src:a.$withBase("/images/minkowski.jpg")}}),a._v(" "),_("br"),a._v("\np为1时为曼哈顿距离(city block)\n"),_("br"),a._v("\np为2时为欧氏距离\n"),_("br"),a._v("\np趋向于无穷时为切比雪夫距离\n"),_("br"),a._v(" "),_("img",{staticStyle:{width:"500px",height:"300px"},attrs:{src:a.$withBase("/images/mdis.jpg")}})]),a._v(" "),_("h4",{attrs:{id:"cosine-similarity"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cosine-similarity"}},[a._v("#")]),a._v(" Cosine Similarity")]),a._v(" "),_("p",[a._v("cos(d1, d2) =  (d1 · d2) /||d1|| ||d2||\n"),_("br"),a._v("\n点乘：两两数据单位相乘再相加。\n||D||：向量D的长度，点乘自身后再开根号。")]),a._v(" "),_("h2",{attrs:{id:"数据仓库和数据挖掘的olap技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据仓库和数据挖掘的olap技术"}},[a._v("#")]),a._v(" 数据仓库和数据挖掘的OLAP技术")]),a._v(" "),_("h3",{attrs:{id:"什么是数据仓库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是数据仓库"}},[a._v("#")]),a._v(" 什么是数据仓库")]),a._v(" "),_("p",[a._v("首先，数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理决策制定。\n与关系数据库、事物处理系统和文件系统是有区别的。")]),a._v(" "),_("h4",{attrs:{id:"面向主题的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面向主题的"}},[a._v("#")]),a._v(" 面向主题的")]),a._v(" "),_("p",[a._v("数据仓库"),_("strong",[a._v("只关注")]),a._v("决策者的数据建模与分析，而不是日常操作和事务处理。\n因此，数据仓库不会关注对于决策无用的数据，而是提供决策主题的简明视图")]),a._v(" "),_("h4",{attrs:{id:"集成的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集成的"}},[a._v("#")]),a._v(" 集成的")]),a._v(" "),_("p",[a._v("数据仓库是将多个异种数据源（如关系数据库、一般文件和联机事务）集成在一起。")]),a._v(" "),_("h4",{attrs:{id:"时变的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#时变的"}},[a._v("#")]),a._v(" 时变的")]),a._v(" "),_("p",[a._v("数据存储从历史的角度（过去5-10年）提供信息。")]),a._v(" "),_("h4",{attrs:{id:"非易失的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非易失的"}},[a._v("#")]),a._v(" 非易失的")]),a._v(" "),_("p",[a._v("数据仓库总是物理地分离存放数据。")]),a._v(" "),_("h3",{attrs:{id:"为什么需要一个分离的数据仓库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要一个分离的数据仓库"}},[a._v("#")]),a._v(" 为什么需要一个分离的数据仓库")]),a._v(" "),_("h4",{attrs:{id:"分离是为了提高两个系统的性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分离是为了提高两个系统的性能"}},[a._v("#")]),a._v(" 分离是为了提高两个系统的性能")]),a._v(" "),_("p",[a._v("若在操作数据库中处理OLAP查询，可能会降低操作任务的性能")]),a._v(" "),_("h4",{attrs:{id:"分离是为了提高两个系统的性能-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分离是为了提高两个系统的性能-2"}},[a._v("#")]),a._v(" 分离是为了提高两个系统的性能")]),a._v(" "),_("p",[a._v("并行机制不适用于OLAP，OLAP查询一般只需要对数据记录进行只读访问")]),a._v(" "),_("h4",{attrs:{id:"决策支持需要历史数据-而操作数据库一般不维护历史数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#决策支持需要历史数据-而操作数据库一般不维护历史数据"}},[a._v("#")]),a._v(" 决策支持需要历史数据，而操作数据库一般不维护历史数据")]),a._v(" "),_("h2",{attrs:{id:"数据立方体技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据立方体技术"}},[a._v("#")]),a._v(" 数据立方体技术")]),a._v(" "),_("h3",{attrs:{id:"立方体实体化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#立方体实体化"}},[a._v("#")]),a._v(" 立方体实体化")]),a._v(" "),_("p",[a._v("计算冰山立方体的优势\n1、不需要保存或者显示那些值低于阈值的单元格（冰山条件）\n"),_("br"),a._v("\n2、高效的方法甚至可以避免计算不需要的中间单元\n"),_("br"),a._v("\n3、避免爆发式增长")]),a._v(" "),_("h3",{attrs:{id:"立方体计算方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#立方体计算方法"}},[a._v("#")]),a._v(" 立方体计算方法")]),a._v(" "),_("h4",{attrs:{id:"一般启发式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一般启发式"}},[a._v("#")]),a._v(" 一般启发式")]),a._v(" "),_("p",[a._v("可以从先前计算的聚合中计算聚合，而不是从基本事实表中计算。\n")]),_("li",[a._v("最小的孩子：从最小的、先前计算的长方体计算一个长方体。")]),a._v(" "),_("li",[a._v("缓存结果：缓存一个长方体的结果，从中计算其他长方体以减少磁盘I/O")]),a._v(" "),_("li",[a._v("摊销扫描：同时计算尽可能多的长方体以摊销磁盘读取。")]),a._v(" "),_("li",[a._v("共享排序：当使用基本排序的方法时，跨多个长方体共享排序成本。")]),a._v(" "),_("li",[a._v("共享分区：当使用基于哈希的算法时，在多个长方体之间共享分区成本。")]),_("p"),a._v(" "),_("h4",{attrs:{id:"多路阵列聚合-molap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多路阵列聚合-molap"}},[a._v("#")]),a._v(" 多路阵列聚合(MOLAP)")]),a._v(" "),_("p",[a._v("表现：\n"),_("br")]),_("li",[a._v("基于数组的“自上而下”算法(从ABC到AB)")]),a._v(" "),_("li",[a._v("使用多为块")]),a._v(" "),_("li",[a._v("多维度同时聚合")]),a._v(" "),_("li",[a._v("中间聚合值被重新用于计算祖先长方体")]),a._v(" "),_("li",[a._v("不能做Apriori修剪；没有冰山优化")]),a._v(" "),_("br"),a._v("\n特点：\n"),_("br"),a._v(" "),_("li",[a._v("有效计算少量维度的完整立方体")]),a._v(" "),_("li",[a._v("如果有大量维度，则应使用“自顶向下”计算和冰山立方计算方法")]),a._v(" "),_("br"),a._v("\n步骤：\n"),_("br"),a._v(" "),_("li",[a._v("将数组分成块(适合内存的小子多维数据集)")]),a._v(" "),_("li",[a._v("压缩稀疏数组寻址:(chunk_id.offset)")]),a._v(" "),_("li",[a._v("通过以最优化访问每个单元的次数的顺序访问立方体单元来“多路计算聚合”，并降低内存访问和存储成本。 ")]),_("p"),a._v(" "),_("h4",{attrs:{id:"使用壳碎片进行在线查询计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用壳碎片进行在线查询计算"}},[a._v("#")]),a._v(" 使用壳碎片进行在线查询计算")]),a._v(" "),_("p",[a._v("方法：给定物化片段立方体\n")]),_("li",[a._v("将查询分片，同壳碎片 ")]),a._v(" "),_("li",[a._v("从片段立方体中获取每个片段对应的TID列表")]),a._v(" "),_("li",[a._v("将每个片段的TID列表相交以构建实例化的基表")]),a._v(" "),_("li",[a._v("使用带有任何立方算法的基表计算数据立方体")]),_("p"),a._v(" "),_("h4",{attrs:{id:"立方体空间中的数据挖掘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#立方体空间中的数据挖掘"}},[a._v("#")]),a._v(" 立方体空间中的数据挖掘")]),a._v(" "),_("p",[a._v("数据立方体大大增加了分析带宽\n"),_("br")]),a._v(" "),_("p",[_("strong",[a._v("OLAP式分析和数据挖掘交互的四种方式")])]),_("li",[a._v("使用立方体空间定义挖掘的数据空间")]),a._v(" "),_("li",[a._v("使用OLAP查询生成用于挖掘的特征和目标")]),a._v(" "),_("li",[a._v("在多步挖掘过程中使用数据挖掘模型作为构建块——如预测立方体")]),a._v(" "),_("li",[a._v("使用数据立方体计算技术加速重复模型构建")]),_("p"),a._v(" "),_("h3",{attrs:{id:"数据预处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据预处理"}},[a._v("#")]),a._v(" 数据预处理")]),a._v(" "),_("p",[a._v("为什么要预处理数据？ 是因为要将数据质量满足应用要求。数据质量有三个要素： "),_("strong",[a._v("准确性、完整性和一致性")]),a._v("。\n实效性、可信性（反映有多少数据是用户信赖的）和可解释性（反映数据是否容易理解）同样影响数据质量。")]),a._v(" "),_("h3",{attrs:{id:"数据预处理的主要任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据预处理的主要任务"}},[a._v("#")]),a._v(" 数据预处理的主要任务")]),a._v(" "),_("p",[a._v("四个步骤：数据清理、数据集成、数据归约、数据变换")]),a._v(" "),_("h4",{attrs:{id:"数据清理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据清理"}},[a._v("#")]),a._v(" 数据清理")]),a._v(" "),_("p",[a._v("现实世界的数据一般是不完整的、有噪声的和不一致的。")]),a._v(" "),_("h5",{attrs:{id:"缺失值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺失值"}},[a._v("#")]),a._v(" 缺失值")]),a._v(" "),_("p",[a._v("当许多元组的一些属性没有值时。可使用最可能的值填充缺失值。比如可以使用回归、贝叶斯形式化的方法或决策树归纳确定该缺失值。\n好的数据库和数据输入设计将有助于在第一现场把缺失值或错误的数量降到最低。")]),a._v(" "),_("h4",{attrs:{id:"噪声"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#噪声"}},[a._v("#")]),a._v(" 噪声")]),a._v(" "),_("p",[a._v("噪声是被测量变量的随机误差或者方差。数据光滑技术用于去掉噪声，例如有分箱、回归、离群点分析这些方法。")]),a._v(" "),_("h3",{attrs:{id:"数据集成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据集成"}},[a._v("#")]),a._v(" 数据集成")]),a._v(" "),_("p",[a._v("数据挖掘经常需要合并来自多个数据存储的数据。")]),a._v(" "),_("h4",{attrs:{id:"实体识别问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实体识别问题"}},[a._v("#")]),a._v(" 实体识别问题")]),a._v(" "),_("p",[a._v("考虑的问题是来自多个信息源的等价实体该如何才能匹配？比如一个数据库的customer_id与另一个cust_number指的是相同的属性。")]),a._v(" "),_("h4",{attrs:{id:"冗余和相关分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#冗余和相关分析"}},[a._v("#")]),a._v(" 冗余和相关分析")]),a._v(" "),_("p",[a._v("冗余是数据集成的另一个重要问题，一个属性可能由另一个属性导出，则这个属性可能是冗余的。属性或维(列)命名的不一致也会导致冗余。\n可以使用"),_("strong",[a._v("相关分析")]),a._v("检测是否有冗余\n"),_("br"),a._v("\n1、标称数据的卡方相关检验\n"),_("br"),a._v("\n对于标称数据，两个属性A和B之间的相关联系可以通过卡方检验发现。卡方统计检验假设A和B是独立的。如果拒绝该假设，则证明A和B是统计相关的。仔细学习3.1的例题\n"),_("br"),a._v("\n2、数值数据的相关系数\n"),_("br"),a._v("\n对于数值数据，可以计算A和B的相关系数，估计其相关度。-1<=r(A,B)<=+1，若r(A,B)大于0则A和B是正相关的。该值越大，相关性越强。\n所以，一个较高的r(A,B)可以作为冗余被删除。")]),a._v(" "),_("h2",{attrs:{id:"分类问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分类问题"}},[a._v("#")]),a._v(" 分类问题")]),a._v(" "),_("h3",{attrs:{id:"逻辑回归"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#逻辑回归"}},[a._v("#")]),a._v(" 逻辑回归")]),a._v(" "),_("p",[a._v("逻辑回归是来解决二分类问题的方法(解决分类问题)\n"),_("br"),a._v("\n逻辑回归 = 线性回归 + sigmoid函数\n"),_("br"),a._v("\n回顾：1、线性回归是用一条直线来拟合自变量和因变量之间的关系\n"),_("br"),a._v("\n2、sigmoid函数： y = 1 / 1 + e^-z\n"),_("br"),a._v("\n逻辑回归： y = 1 / 1 + e^( -w * x + b )")]),a._v(" "),_("h3",{attrs:{id:"分类和回归的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分类和回归的区别"}},[a._v("#")]),a._v(" 分类和回归的区别")]),a._v(" "),_("li",[a._v("回归模型的输出是 **连续** 的")]),a._v(" "),_("li",[a._v("分类模型的输出是 **离散** 的")]),a._v(" "),_("br"),a._v("\nc = -[ylna + (1-y)ln(1-a)]\n损失函数：预测值与实际值相似程度的函数，损失函数越小，模型越好。\n"),_("br"),a._v("\n可以用spark实现\n"),_("h3",{attrs:{id:"特征选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#特征选择"}},[a._v("#")]),a._v(" 特征选择")]),a._v(" "),_("h3",{attrs:{id:"数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据"}},[a._v("#")]),a._v(" 数据")]),a._v(" "),_("p",[a._v("数据应当分为训练集和测试集。顾名思义，在训练好模型后，要使用测试集去校验模型。\n"),_("br"),a._v("\n混淆矩阵(Confusion Matrix)：准确率为 (TP+TN)/(P+N)\n"),_("br"),a._v("\nROC曲线：AOC和Random guess曲线\nAOC曲线：性能指标曲线，越接近1越好")]),a._v(" "),_("h2",{attrs:{id:"聚类问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聚类问题"}},[a._v("#")]),a._v(" 聚类问题")])])}),[],!1,null,null,null);t.default=r.exports}}]);